// Copyright (c) 2017 George Tankersley. All rights reserved.
// Copyright (c) 2020-2021 Oasis Labs Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//go:build ignore

package main

import (
	"fmt"
	"os"

	. "github.com/mmcloughlin/avo/build"
	. "github.com/mmcloughlin/avo/operand"
	. "github.com/mmcloughlin/avo/reg"
)

func main() {
	for i, step := range []func() error{
		SetCommon,
		FeMul,
		FePow2k,
	} {
		if err := step(); err != nil {
			fmt.Printf("step %d failed: %v", i, err)
			os.Exit(1)
		}
	}

	Generate()
}

// These routines are based on the ristretto255 package by
// George Tankersley.  The changes made are as follows:
//
//  * Abstract out the reduction and carry into common code.
//  * Instead of feSquare, implement fePow2k.
//  * Use avo, because all the cool kids are doing it.

func reduce64(r00, r01, r10, r11, r20, r21, r30, r31, r40, r41 GPVirtual) {
	Comment("Reduce")
	MOVQ(U64((1<<51)-1), RAX) // rax <-- mask51
	mask51 := RAX

	SHLQ(Imm(13), r00, r01)   // r01 = shld with r00
	ANDQ(mask51, r00)         // r00 &= mask51
	SHLQ(Imm(13), r10, r11)   // r11 = shld with r10
	ANDQ(mask51, r10)         // r10 &= mask51
	ADDQ(r01, r10)            // r10 += r01
	SHLQ(Imm(13), r20, r21)   // r21 = shld with r20
	ANDQ(mask51, r20)         // r20 &= mask51
	ADDQ(r11, r20)            // r20 += r11
	SHLQ(Imm(13), r30, r31)   // r31 = shld with r30
	ANDQ(mask51, r30)         // r30 &= mask51
	ADDQ(r21, r30)            // r30 += r21
	SHLQ(Imm(13), r40, r41)   // r41 = shld with r40
	ANDQ(mask51, r40)         // r40 &= mask51
	ADDQ(r31, r40)            // r40 += r31
	IMUL3Q(Imm(19), r41, r41) // r41 *= 19
	ADDQ(r41, r00)            // r00 += r41

	t0, t1, t2, t3, t4 := r01, r11, r21, r31, r41
	MOVQ(r00, t0)           // t0 <-- r00
	MOVQ(r10, t1)           // t1 <-- r10
	MOVQ(r20, t2)           // t2 <-- r20
	MOVQ(r30, t3)           // t3 <-- r30
	MOVQ(r40, t4)           // t4 <-- r40
	ANDQ(mask51, r00)       // r00 &= mask51
	ANDQ(mask51, r10)       // r10 &= mask51
	ANDQ(mask51, r20)       // r20 &= mask51
	ANDQ(mask51, r30)       // r30 &= mask51
	ANDQ(mask51, r40)       // r40 &= mask51
	SHRQ(Imm(51), t0)       // t0 <- r00 >> 51
	SHRQ(Imm(51), t1)       // t1 <- r10 >> 51
	SHRQ(Imm(51), t2)       // t2 <- r20 >> 51
	SHRQ(Imm(51), t3)       // t3 <- r30 >> 51
	SHRQ(Imm(51), t4)       // t4 <- r40 >> 51
	IMUL3Q(Imm(19), t4, t4) // t4 <-- (r40 >> 51) * 19
	ADDQ(t0, r10)           // r10 += t0
	ADDQ(t1, r20)           // r20 += t1
	ADDQ(t2, r30)           // r30 += t2
	ADDQ(t3, r40)           // r40 += t3
	ADDQ(t4, r00)           // r10 += t4
}

func FeMul() error {
	TEXT(
		"feMul",
		NOSPLIT|NOFRAME,
		"func(out, a, b *Element)",
	)

	Comment(
		"Based on assembly generated by PeachPy. Equivalent to the Go in",
		"feMulGeneric, which was originally based on the amd64-51-30k",
		"assembly in SUPERCOP.",
	)

	a := Mem{Base: Load(Param("a"), GP64())}
	b := Mem{Base: Load(Param("b"), GP64())}

	x0, x1, x2, x3, x4 := a.Offset(0), a.Offset(8), a.Offset(16), a.Offset(24), a.Offset(32)
	y0, y1, y2, y3, y4 := b.Offset(0), b.Offset(8), b.Offset(16), b.Offset(24), b.Offset(32)

	Comment("r0 = x0*y0 + x1_19*y4 + x2_19*y3 + x3_19*y2 + x4_19*y1\n")
	r00, r01 := GP64(), GP64()

	Comment("r00, r01 = x0*y0")
	MOVQ(x0, RAX)
	MULQ(y0)
	MOVQ(RAX, r00)
	MOVQ(RDX, r01)

	Comment("r00, r01 += x1_19*y4")
	MOVQ(x1, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y4)
	ADDQ(RAX, r00)
	ADCQ(RDX, r01)

	Comment("r00, r01 += x2_19*y3")
	MOVQ(x2, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y3)
	ADDQ(RAX, r00)
	ADCQ(RDX, r01)

	Comment("r00, r01 += x3_19*y2")
	MOVQ(x3, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y2)
	ADDQ(RAX, r00)
	ADCQ(RDX, r01)

	Comment("r00, r01 += x4_19*y1")
	MOVQ(x4, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y1)
	ADDQ(RAX, r00)
	ADCQ(RDX, r01)

	Comment("r1 = x0*y1 + x1*y0 + x2_19*y4 + x3_19*y3 + x4_19*y2\n")
	r10, r11 := GP64(), GP64()

	Comment("r10, r11 = x0*y1")
	MOVQ(x0, RAX)
	MULQ(y1)
	MOVQ(RAX, r10)
	MOVQ(RDX, r11)

	Comment("r10, r11 += x1*y0")
	MOVQ(x1, RAX)
	MULQ(y0)
	ADDQ(RAX, r10)
	ADCQ(RDX, r11)

	Comment("r10, r11 += x2_19*y4")
	MOVQ(x2, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y4)
	ADDQ(RAX, r10)
	ADCQ(RDX, r11)

	Comment("r10, r11 += x3_19*y3")
	MOVQ(x3, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y3)
	ADDQ(RAX, r10)
	ADCQ(RDX, r11)

	Comment("r10, r11 += x4_19*y2")
	MOVQ(x4, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y2)
	ADDQ(RAX, r10)
	ADCQ(RDX, r11)

	Comment("r2 = x0*y2 + x1*y1 + x2*y0 + x3_19*y4 + x4_19*y3\n")
	r20, r21 := GP64(), GP64()

	Comment("r20, r11 = x0*y2")
	MOVQ(x0, RAX)
	MULQ(y2)
	MOVQ(RAX, r20)
	MOVQ(RDX, r21)

	Comment("r20, r21 += x1*y1")
	MOVQ(x1, RAX)
	MULQ(y1)
	ADDQ(RAX, r20)
	ADCQ(RDX, r21)

	Comment("r20, r21 += x2*y0")
	MOVQ(x2, RAX)
	MULQ(y0)
	ADDQ(RAX, r20)
	ADCQ(RDX, r21)

	Comment("r20, r21 += x3_19*y4")
	MOVQ(x3, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y4)
	ADDQ(RAX, r20)
	ADCQ(RDX, r21)

	Comment("r20, r21 += x4_19*y3")
	MOVQ(x4, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y3)
	ADDQ(RAX, r20)
	ADCQ(RDX, r21)

	Comment("r3 = x0*y3 + x1*y2 + x2*y1 + x3*y0 + x4_19*y4\n")
	r30, r31 := GP64(), GP64()

	Comment("r30, r31 = x0*y3")
	MOVQ(x0, RAX)
	MULQ(y3)
	MOVQ(RAX, r30)
	MOVQ(RDX, r31)

	Comment("r30, r31 += x1*y2")
	MOVQ(x1, RAX)
	MULQ(y2)
	ADDQ(RAX, r30)
	ADCQ(RDX, r31)

	Comment("r30, r31 += x2*y1")
	MOVQ(x2, RAX)
	MULQ(y1)
	ADDQ(RAX, r30)
	ADCQ(RDX, r31)

	Comment("r30, r31 += x3*y0")
	MOVQ(x3, RAX)
	MULQ(y0)
	ADDQ(RAX, r30)
	ADCQ(RDX, r31)

	Comment("r30, r31 += x4_19*y4")
	MOVQ(x4, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(y4)
	ADDQ(RAX, r30)
	ADCQ(RDX, r31)

	Comment("r3 = x0*y4 + x1*y3 + x2*y2 + x3*y1 + x4*y0\n")
	r40, r41 := GP64(), GP64()

	Comment("r40, r31 = x0*y4")
	MOVQ(x0, RAX)
	MULQ(y4)
	MOVQ(RAX, r40)
	MOVQ(RDX, r41)

	Comment("r40, r41 += x1*y3")
	MOVQ(x1, RAX)
	MULQ(y3)
	ADDQ(RAX, r40)
	ADCQ(RDX, r41)

	Comment("r40, r41 += x2*y2")
	MOVQ(x2, RAX)
	MULQ(y2)
	ADDQ(RAX, r40)
	ADCQ(RDX, r41)

	Comment("r40, r41 += x3*y1")
	MOVQ(x3, RAX)
	MULQ(y1)
	ADDQ(RAX, r40)
	ADCQ(RDX, r41)

	Comment("r40, r41 += x4*y0")
	MOVQ(x4, RAX)
	MULQ(y0)
	ADDQ(RAX, r40)
	ADCQ(RDX, r41)

	reduce64(r00, r01, r10, r11, r20, r21, r30, r31, r40, r41)

	Comment("Write out the results")
	out := Mem{Base: Load(Param("out"), GP64())}
	MOVQ(r00, out.Offset(0))
	MOVQ(r10, out.Offset(8))
	MOVQ(r20, out.Offset(16))
	MOVQ(r30, out.Offset(24))
	MOVQ(r40, out.Offset(32))

	RET()

	return nil
}

func FePow2k() error {
	TEXT(
		"fePow2k",
		NOSPLIT|NOFRAME,
		"func(out, a *Element, k uint64)",
	)

	a := Mem{Base: Load(Param("a"), GP64())}
	k := Load(Param("k"), GP64())

	x0, x1, x2, x3, x4 := a.Offset(0), a.Offset(8), a.Offset(16), a.Offset(24), a.Offset(32)

	Label("pow2k_loop")

	Comment("r0 = x0*x0 + x1*38*x4 + x2*38*x3\n")
	r00, r01 := GP64(), GP64()

	Comment("r00, r01 = x0*x0")
	MOVQ(x0, RAX)
	MULQ(x0)
	MOVQ(RAX, r00)
	MOVQ(RDX, r01)

	Comment("r00, r01 += x1*38*x4")
	MOVQ(x1, RDX)
	IMUL3Q(Imm(38), RDX, RAX)
	MULQ(x4)
	ADDQ(RAX, r00)
	ADCQ(RDX, r01)

	Comment("r00, r01 += x2*38*x3")
	MOVQ(x2, RDX)
	IMUL3Q(Imm(38), RDX, RAX)
	MULQ(x3)
	ADDQ(RAX, r00)
	ADCQ(RDX, r01)

	Comment("r1 = x0*2*x1 + x2*38*x4 + x3*19*x3\n")
	r10, r11 := GP64(), GP64()

	Comment("r10, r11 = x0*2*x1")
	MOVQ(x0, RAX)
	SHLQ(Imm(1), RAX)
	MULQ(x1)
	MOVQ(RAX, r10)
	MOVQ(RDX, r11)

	Comment("r10, r11 += x2*38*x4")
	MOVQ(x2, RDX)
	IMUL3Q(Imm(38), RDX, RAX)
	MULQ(x4)
	ADDQ(RAX, r10)
	ADCQ(RDX, r11)

	Comment("r10, r11 += x3*19*x3")
	MOVQ(x3, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(x3)
	ADDQ(RAX, r10)
	ADCQ(RDX, r11)

	Comment("r2 = x0*2*x2 + x1*x1 + x3*38*x4\n")
	r20, r21 := GP64(), GP64()

	Comment("r20, r21 = x0*2*x2")
	MOVQ(x0, RAX)
	SHLQ(Imm(1), RAX)
	MULQ(x2)
	MOVQ(RAX, r20)
	MOVQ(RDX, r21)

	Comment("r20, r21 += x1*x1")
	MOVQ(x1, RAX)
	MULQ(x1)
	ADDQ(RAX, r20)
	ADCQ(RDX, r21)

	Comment("r20, r21 += x3*38*x4")
	MOVQ(x3, RDX)
	IMUL3Q(Imm(38), RDX, RAX)
	MULQ(x4)
	ADDQ(RAX, r20)
	ADCQ(RDX, r21)

	Comment("r3 = x0*2*x3 + x1*2*x2 + x4*19*x4\n")
	r30, r31 := GP64(), GP64()

	Comment("r30, r31 = x0*2*x3")
	MOVQ(x0, RAX)
	SHLQ(Imm(1), RAX)
	MULQ(x3)
	MOVQ(RAX, r30)
	MOVQ(RDX, r31)

	Comment("r30, r31 += x1*2*x2")
	MOVQ(x1, RAX)
	SHLQ(Imm(1), RAX)
	MULQ(x2)
	ADDQ(RAX, r30)
	ADCQ(RDX, r31)

	Comment("r30, r31 += x4*19*x4")
	MOVQ(x4, RDX)
	IMUL3Q(Imm(19), RDX, RAX)
	MULQ(x4)
	ADDQ(RAX, r30)
	ADCQ(RDX, r31)

	Comment("r4 = x0*2*x4 + x1*2*x3 + x2*x2\n")
	r40, r41 := GP64(), GP64()

	Comment("r40, r41 = x0*2*x4")
	MOVQ(x0, RAX)
	SHLQ(Imm(1), RAX)
	MULQ(x4)
	MOVQ(RAX, r40)
	MOVQ(RDX, r41)

	Comment("r40, r41 += x1*2*x3")
	MOVQ(x1, RAX)
	SHLQ(Imm(1), RAX)
	MULQ(x3)
	ADDQ(RAX, r40)
	ADCQ(RDX, r41)

	Comment("r40, r41 += x2*x2")
	MOVQ(x2, RAX)
	MULQ(x2)
	ADDQ(RAX, r40)
	ADCQ(RDX, r41)

	reduce64(r00, r01, r10, r11, r20, r21, r30, r31, r40, r41)

	Comment("Write out the results")
	Load(Param("out"), a.Base) // Rewrite a.Base to be `out`, so it gets loaded next iteration.
	MOVQ(r00, a.Offset(0))
	MOVQ(r10, a.Offset(8))
	MOVQ(r20, a.Offset(16))
	MOVQ(r30, a.Offset(24))
	MOVQ(r40, a.Offset(32))

	DECQ(k)
	JNZ(LabelRef("pow2k_loop"))

	RET()

	return nil
}
